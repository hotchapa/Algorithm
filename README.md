# **오늘의 알고리즘 풀이**
### 2024-04-17 (수)
---

문제이름|알고리즘|난이도|링크|
|:---:|:---:|:---:|:---:|
|[농장 관리](https://www.acmicpc.net/problem/1245)|<span style="color:orange">**DFS**</span>|골드 5|[풀이](https://github.com/hotchapa/Algorithm/blob/137459848df6f77854a0a0170e2581ce21c347ca/JS/Baekjoon/1660.js)|


### 문제 풀이 과정 정리

**1. 답지 참고 여부 및 고민한 시간**  
- 보지 않음
- 2시간

**2. 도전한 풀이 방법과 선택 이유**  
인접한 격자의 집합을 찾고, 봉우리가 아닌지 여부를 판단하는 문제이므로, 그래프 이론에 해당하는 DFS나 BFS를 생각했는데, 개인적으론 BFS보다 DFS로 풀이하는 게 익숙하여 DFS로 풀었다.

거기다 N과 M의 값이
 N(1 < N ≤ 100), M(1 < M ≤ 70)
 이므로, 상당히 자비롭다. 
 
 그래서 DFS로 풀이해도 시간초과가 날 것 같진 않다고 생각해 DFS로 풀이했다.

**3. 풀이 방법**  
일단 처음에는 

**4. 코드 작성 시 신경 쓴 부분**  
- **가독성:** `visited` 배열을 사용하여 이미 검사한 셀을 중복해서 검사하지 않도록 했습니다. 이는 함수 호출 수를 줄이고, 전체적인 성능을 향상시키는 데 도움이 됩니다.
- 
- **로직의 명확성:** `dfs` 함수 내에서 피크 여부를 판단하는 로직을 명확하게 구현하여 코드의 이해도를 높였습니다. 특히, 모든 방향을 체계적으로 검사하는 부분에 주의를 기울였습니다.

**5. 어려움을 느꼈던 부분**  
- **방향 설정** 
  인접한 격자라길래, 처음에 4방향만 고려했었다. 그래서 자꾸 답이 틀리게 나와서 진이 빠졌는데.. 문제를 다시보니까

  (여기서 "인접하다"의 정의는 X좌표 차이와 Y좌표 차이 모두 1 이하일 경우로 정의)

  라는 설명이 있었다. 즉 8방향까지 고려해야한다는 것이었다. 결국 문제를 다시 읽고나서야 dx,dy를 수정하여 문제를 제대로 풀 수 있었다.

- **재귀 함수의 조건 설정** 
  `dfs` 함수에서 재귀 호출의 종료 조건과 인자를 설정하는 것이 어려웠다. 
  
  처음엔 dfs 인자에 h를 넣지않고,
  arr[nx][ny]와 arr[x][y] 값만 비교했었는데, 이러면 arr[x][y]의 주변의 8방향이 모두 작은지 재귀호출을 해야하고, 또 같을 경우에도 재귀호출을 해야하니까 비효율적이다. 그래서 로직을 뜯어고쳐,h가 arr[nx][ny]
