# **오늘의 알고리즘**
### 2024-04-01 (월)
---

문제이름|알고리즘|난이도|링크|
|:---:|:---:|:---:|:---:|
|[타겟 넘버](https://programmers.co.kr/learn/courses/30/lessons/43165)|<span style="color:green">**DFS/BFS**</span>|레벨 2|[풀이](https://github.com/hotchapa/Algorithm/blob/53a5babc6bc538270e24f5460d045ad68dcc5636/JS/Baekjoon/%ED%83%80%EA%B2%9F%EB%84%98%EB%B2%84.js)|

## 문제 풀이 과정

주어진 숫자 배열을 사용하여 지정된 타겟 넘버를 만들 수 있는 모든 경우의 수를 찾는 문제다. DFS(깊이 우선 탐색)를 활용하여 모든 가능한 숫자 조합을 탐색하고, 조합의 합이 타겟 넘버와 일치하는 경우의 수를 계산한다.

### 1) 입력 처리 및 초기화
- 숫자 배열 `numbers`와 타겟 넘버 `target`이 주어진다.
- DFS 탐색을 위해 인덱스, 현재 합계, `numbers`, `target`을 인자로 받는 재귀 함수를 정의한다.

### 2) DFS를 이용한 영역 탐색
- 모든 숫자에 대해 두 가지 경우를 고려한다: 현재 숫자를 더하는 경우와 빼는 경우.
- 재귀적으로 다음 숫자로 넘어가며, 모든 숫자를 사용했을 때(`index == numbers.length`) 현재 합계가 타겟 넘버와 같은지 확인한다.

### 3) 조건에 따른 경우의 수 계산
- 탐색 과정에서 타겟 넘버와 일치하는 합계를 찾을 때마다 경우의 수를 1씩 증가시킨다.
- 모든 경우를 탐색한 후, 경우의 수를 반환한다.

### 4) 결과 출력
- 최종적으로 계산된 경우의 수를 출력한다.

## 풀이 후 느낀점
원래는 코드를 굉장히 지저분하게 작성했었다. 조건문 범벅을 해버렸었는데, 삼항 연산자를 적용하니 훨씬 보기 깔끔해졌다. 간단한 조건이라면 적극 활용해야겠다는 생각이 든다.