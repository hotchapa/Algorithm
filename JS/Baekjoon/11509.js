// 문제
// 큰 방에 N개의 풍선이 떠있다. 풍선들은 왼쪽부터 오른쪽까지 일렬로 있다. 진솔이는 화살 가지고 노는 것과 사냥 연습하는 것을 좋아한다. 진솔이는 화살을 왼쪽에서 오른쪽으로 쏜다. 높이는 임의로 선택한다. 화살은 선택된 높이 H에서 풍선을 마주칠 때까지 왼쪽에서 오른쪽으로 이동한다. 화살이 풍선을 마주치는 순간, 풍선은 터지고 사라진다. 화살은 계속해서 가던길을 가는데 높이는 1 줄어든다. 그러므로 만약 화살이 높이 H에서 이동 중이었다면 풍선을 터트린 후에는 높이가 H-1이 된다.
// 우리의 목표는 모든 풍선을 터트리되 가능한한 적은 화살을 사용하는 것이다.

// 문제 풀이
// 사용 알고리즘 : 그리디
// 풀이 방법

// 1) 화살은 왼쪽에서 오른쪽으로만 이동하므로, 가장 높은 위치에서 쏜다고 해서 풍선 전부를 관통할 수 있는 게 아니다
// 2) 풍선의 높이를 순회하면서, 바로 뒷 풍선이 현재 풍선 높이보다 낮다면 관통시키고, 그게 아니라면 관통을 종료한다.
// 3) 풍선을 터뜨리면 화살 높이가 1씩 줄어드는 것에 유의한다.
// 4) arrows라는 배열을 만드는데, 이 배열은 각 높이에서 화살이 얼마나 많이 남아있는지를 기록한다
// 5) 풍선을 검사할 때, 만약 현재 풍선의 높이에서 화살이 없다면, 새로운 화살을 쏘아 풍선을 터트린다.
//    그리고 화살이 풍선을 터트리고 난 후의 높이(현재 풍선의 높이 - 1)에 화살이 하나 더 있다고 기록한다
// 6) 만약 현재 풍선의 높이에서 화살이 있다면, 그 화살로 풍선을 터트리고, 
//    화살이 풍선을 터트리고 난 후의 높이에 화살이 하나 더 있다고 기록한다

const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "./input.txt";
let input = fs.readFileSync(filePath).toString().trim().split("\n");
let n = input[0]*1;
let balloons = input[1].split(" ").map(x=>+x);
let arrows = Array(1000001).fill(0);
let count = 0;

for(let i of balloons){
  if(arrows[i] > 0){
    arrows[i] -= 1;
    arrows[i-1] += 1;
  }else{
    arrows[i- 1] += 1;
    count += 1; 
  }
}

console.log(count);


