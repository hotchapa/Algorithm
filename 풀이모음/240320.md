# **오늘의 알고리즘**
### 2024-03-20 (수)
---

문제이름|알고리즘|난이도|링크|
|:---:|:---:|:---:|:---:|
|[플로이드](https://www.acmicpc.net/problem/11404)|<span style="color:red">**Floyd-Warshall**</span>|골드4|[풀이](https://github.com/hotchapa/Algorithm/blob/11065638e2da0a65c6b1db47e26ceeaf6cdaa1e7/JS/Baekjoon/11404.js)|


## 문제 풀이 과정

플로이드 워셜 알고리즘을 이용해 모든 도시 간의 최소 비용을 구하는 문제였다. 문제의 핵심은 모든 도시를 서로 연결하는 최단 경로를 찾는 것이며, 주어진 도시(노드)의 개수가 최대 100개이므로 \(N^3\)의 시간 복잡도를 가진 플로이드 워셜 알고리즘으로 해결 가능하다.

### 1) 입력 처리 및 초기화
- 도시의 수 `n`과 버스의 수 `m`을 입력 받는다.
- `graph` 배열을 이용해 모든 도시 간의 초기 비용을 매우 큰 값(1e9)으로 설정하여, 간선이 없는 경우를 나타낸다.
- 각 도시 자신으로 가는 비용은 0으로 설정한다.

### 2) 간선 정보 업데이트
- 두 도시 간 여러 개의 버스가 있을 수 있으므로, 두 도시를 연결하는 최소 비용만을 저장한다.

### 3) 플로이드 워셜 알고리즘 적용
- 모든 도시 쌍에 대하여, 각 도시를 거치는 경우를 고려하여 최소 비용을 계산한다.
- 이 과정에서 각 도시를 거쳐 가는 것이 직접 가는 것보다 비용이 적을 경우, 해당 비용으로 업데이트한다.

### 4) 결과 출력
- 계산된 최소 비용을 출력한다. 도달할 수 없는 경우 0을 출력한다.

## 풀이 후 느낀점
플로이드 워셜은 \(N^3\)의 시간 복잡도를 가졌는데, 만약 N의 개수가 100개가 아니라 1만개가 넘어가는 큰 수였다면, 문제 내용을 더 보지 않아도, "아,플로이드로 푸는 문제가 아니구나"라고 인식할 수 있었을 것이다.

이런 것처럼, 문제의 조건을 보고, 어떤 알고리즘을 쓰는 게 좋을지 판단하는 능력을 길러야함을 느꼈다. 그리고, 의외로 출력을 제대로 해내는 능력도 중요하다고 느꼈다. line 에다가 최소 비용을 더하는 과정에서 은근 많은 시간을 소요했다. 

문법을 센스있게 다루는 연습이 절실하다.