# **오늘의 알고리즘 풀이**
### 2024-04-06 (토)
---

문제이름|알고리즘|난이도|링크|
|:---:|:---:|:---:|:---:|
|[백준 11048 이동하기](https://www.acmicpc.net/problem/11048)|<span style="color:green">**동적 프로그래밍**</span>|실버 2|[풀이](https://github.com/hotchapa/Algorithm/blob/97b8dd3d9bf5195bffdcafd1ed96403e5b4462c5/JS/Baekjoon/11048.js)|

## 문제 풀이 과정

2차원 배열의 각 칸에 사탕이 배치되어 있고, (1, 1) 위치에서 시작하여 (N, M) 위치까지 이동하면서, 수집할 수 있는 사탕의 최대 개수를 구하는 문제!
이동은 오른쪽, 아래, 오른쪽 아래 대각선 방향으로만 가능하다.

1) `dp` 배열을 사용하여 문제를 해결한다.

2) `dp` 배열의 각 칸에는 해당 위치까지 도달했을 때 수집할 수 있는 사탕의 최대 개수를 저장한다.

3) (1, 1) 위치의 `dp` 값은 초기 위치의 사탕 개수 그 자체이다. (`dp[0][0] = arr[0][0]`)

4) 배열의 첫 행과 첫 열을 초기화한다. 첫 행은 왼쪽에서 오른쪽으로, 첫 열은 위에서 아래로 이동하는 경우만 고려한다.

5) 배열의 나머지 부분을 채우기 위해, 각 위치에 대해 세 가지 이동 경로(왼쪽에서 오는 경우, 위에서 오는 경우, 왼쪽 위 대각선에서 오는 경우) 중에서 최대 값을 선택하여 현재 위치의 사탕 수와 더한다.

6) 이 과정을 반복하며, (N, M) 위치까지의 최대 사탕 개수를 구한다.

7) 마지막 위치인 `dp[N-1][M-1]`에 저장된 값이 최대로 수집할 수 있는 사탕의 개수가 된다.

## 풀이 후 느낀점
다시 한번 동적 프로그래밍의 기본 원리를 이해할 수 있었다. 핵심은 "각 단계에서 최적의 선택을 하는 것이며, 이전 단계의 결과를 활용하여 현재 단계의 결과를 도출해내는 것" 
이번 문제의 점화식은 빠르고 쉽게 세웠는데, 기분이 좋았다 ㅎㅎ