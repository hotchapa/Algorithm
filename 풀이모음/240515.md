# **오늘의 알고리즘 풀이**
### 2024-05-15 (수)
---

문제이름|알고리즘|난이도|링크|
|:---:|:---:|:---:|:---:|
|[전깃줄](https://www.acmicpc.net/problem/2565)|<span style="color:red">**DP,LIS**</span>|골드 5|[풀이](https://github.com/hotchapa/Algorithm/blob/284a46be598defecc1e54704c6279e7560a2d207/JS/Baekjoon/2565.js)|


## 문제 풀이 과정 정리

### 1. 답지 참고 여부 및 고민한 시간
- 봄
- 30분

### 2. 도전한 풀이 방법과 선택 이유
  문제를 어떻게 풀어야할지 모르겠어서, 완전탐색으로라도 풀어보려 했는데 N개의 전깃줄의 부분집합을 하나하나 고려하면, 시간복잡도가 2^n 이 나올것이고, 여기에서 또 전깃줄 교차검증을 하면 n^2을 곱해야할 수도 있으니 불가능하다고 생각했다. 딱 30분만 고민하다가, 아예 모르겠어서 바로 답지를 보았는데, LIS의 응용문제였다. 전깃줄을 오름차순 정렬하면 LIS 문제로 풀이할 수 있는 것이었다.

### 3. 풀이 방법

  1. LIS 문제로 변환을 위해 첫째줄을 기준으로 오름차순 정렬.
  2. 둘째줄을 기준으로 LIS를 찾는다 => 다음 값이 이전 값보다 크다면 새롭게 부분 수열을 시작함.
  3. dp 배열을 사용해서 부분 수열을 찾고, 비교해나가며 값을 갱신함.
  4. dp 배열 내의 가장 큰 값 (LIS)를 N의 개수에서 빼면 제거해야 할 전깃줄 수를 구할 수 있음.

### 4. 코드 작성 시 신경 쓴 부분

없음.

### 5. 어려움을 느꼈던 부분 

**[LIS]**

예전에 LIS 문제를 풀었음에도 오래 헤맸다. 특히 전체 전깃줄에서 꼬이지 않는 전깃줄 수를 빼면 답을 구할 수 있다는 점도 분명히 예전 LIS 응용 문제 때 경험했을텐데, 떠올리지 못했던 점이 아쉬웠다.