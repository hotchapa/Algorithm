# **오늘의 알고리즘 풀이**
### 2024-04-29 (월)
---

문제이름|알고리즘|난이도|링크|
|:---:|:---:|:---:|:---:|
|[통나무 건너뛰기](https://www.acmicpc.net/problem/11497)|<span style="color:red">**그리디**</span>|실버 1|[풀이](https://github.com/hotchapa/Algorithm/blob/af59d93825df0123b4210fd423abffae6d1cdf76/JS/Baekjoon/11497.js)|


## 문제 풀이 과정 정리

### 1. 답지 참고 여부 및 고민한 시간
- 보지 않음
- 40분

### 2. 도전한 풀이 방법과 선택 이유
  배열 내 원소의 순서를 바꾸는 모든 경우의 수는 N!이라 그 수가 너무 많기 때문에, 먼저 정렬을 한 다음 그리디를 적용하는 것이 좋겠다고 생각했다.
  
  오름차순으로 정렬한 뒤, 가장 큰 값을 중앙에 두고, 양 옆을 그 다음으로 큰 값으로 채워나가는 식으로 정렬하면 양끝 통나무를 고려한 높이차의 최소값을 구할 수 있다.

### 3. 풀이 방법

  1. `newArr` 배열을 크기 N에 맞추어 0으로 초기화하고, 입력된 통나무 높이를 오름차순으로 정렬함.

  2. 배열의 중앙에서 시작하여, 가장 높은 통나무를 중앙에 배치하고, 나머지를 양쪽 끝에서 중앙으로 번갈아 가며 배치함.

  3. 이렇게 배치된 통나무 배열에서 인접한 통나무들 간의 높이 차를 계산하고, 각 인덱스를 순회하면서 발생하는 최대 높이 차를 찾아냄.

  4. 모든 테스트 케이스에 대해 계산된 최대 높이 차를 출력함.


### 4. 코드 작성 시 신경 쓴 부분

**[인덱싱]**

인덱싱을 활용해, 최대한 시간 복잡도를 줄였다.

### 5. 어려움을 느꼈던 부분 

**[불필요한 선언 및 가독성 개선]**

처음엔 문제 풀기에 급급해, index, j, k 등 가독성이 떨어지는 변수를 사용했다. 한참 풀이하다, 변수 값이 헷갈려 문제 풀이에 어려움을 겪었다. 배열 범위를 벗어나는 오류를 겪어 이 부분에 시간 소요가 있었다. 

애초에 right, left로 선언했으면 훨씬 알아보기 쉬웠을것이다.

또 코드를 한번에 작성할 수 있는 부분도 여러줄에 거쳐 작성했는데, 아래와 같이 고칠 수 있었을 것이다. 

``  const arr = input[i+1].split(" ").map(Number).sort((a, b) => a - b);
``

