# **오늘의 알고리즘 풀이**
### 2024-04-08 (월)
---

문제이름|알고리즘|난이도|링크|
|:---:|:---:|:---:|:---:|
|[백준 1080 행렬](https://www.acmicpc.net/problem/1080)|<span style="color:orange">**그리디 알고리즘**</span>|실버 1|[풀이](https://github.com/hotchapa/Algorithm/blob/57c9e85c8c9b6153eb23bbe4e5012ba1109860cb/JS/Baekjoon/1080.js)|

## 문제 풀이 과정

이 문제에서는 N×M 크기의 두 행렬 A와 B가 주어지며, A를 B로 만드는 최소 횟수를 구하는 문제이다. 여기서 포인트는 3×3 크기의 부분 행렬에 있는 모든 원소를 뒤집는 것!

1) 입력으로 주어진 두 행렬 `arr`과 `goal`을 비교하여 다른 부분이 있으면, 그 부분의 좌측 상단에서 시작하는 3x3 크기의 부분 행렬을 뒤집는다.

2) 행렬을 뒤집는 작업은, 주어진 좌표(x, y)부터 (x+2, y+2)까지의 범위에 해당하는 모든 원소의 값을 변경(0→1, 1→0)하는 `flip` 함수를 통해 이루어진다.

3) 전체 행렬을 순회하며, `arr`의 원소가 `goal`의 원소와 다를 때마다 `flip` 함수를 호출하여 뒤집고, 뒤집은 횟수를 카운트한다.

4) 모든 가능한 부분 행렬에 대해 뒤집기를 시도한 후, 최종적으로 `arr`과 `goal`이 완전히 동일한지 검사한다. 이를 위한 `isSame` 함수는 두 행렬의 모든 원소를 비교하여 같으면 `true`, 하나라도 다르면 `false`를 반환한다.

5) 만약 최종적으로 두 행렬이 동일하다면, 수행한 뒤집기 연산의 횟수를 출력한다. 만약 동일하지 않다면, 주어진 연산으로는 A를 B로 만들 수 없음을 의미하므로 `-1`을 출력한다.

## 풀이 후 느낀점
arr[i][j]와 goal[i][j]가 다르면 3x3 부분 행렬 뒤집는다는 생각을 바로 못했다. 3x3 영역 조건에 매몰돼서, 3x3의 영역이 전부 다를때에만 뒤집어야 하는 거 아닌가? 라는 이상한 생각을 했다. 덕분에 시간 낭비를 했는데, 알고보면 쉬운 문제였다. 

풀이용 함수를 2개로 나누어 풀이했는데, 훨씬 가독성이 좋은 것 같다.