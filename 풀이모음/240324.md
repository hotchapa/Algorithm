# **오늘의 알고리즘**
### 2024-03-24 (일)
---

문제이름|알고리즘|난이도|링크|
|:---:|:---:|:---:|:---:|
|[트리](https://www.acmicpc.net/problem/1068)|<span style="color:green">**Tree**</span>|골드5|[풀이](https://github.com/hotchapa/Algorithm/blob/3dd7b9e3f29c87edf0cb5f08d837d7eaa4e9776b/JS/Baekjoon/1068.js)|

## 문제 풀이 과정

트리 구조에서 특정 노드를 삭제한 후, 남은 트리에서 리프 노드의 개수를 계산하는 문제였다.

### 1) 입력 처리 및 초기화
- 노드의 개수와 각 노드의 부모 노드 정보를 입력 받는다.
- 삭제할 노드 번호를 입력 받는다.
- 부모 노드 정보를 이용해 트리를 구성한다. 각 노드마다 자식 노드 목록을 저장하기 위한 배열을 사용한다.

### 2) 트리 조작과 탐색
- 입력 받은 정보로부터 트리를 구성한 후, 지정된 노드와 그 노드의 자식 노드들을 재귀적으로 삭제한다.
- 트리의 리프 노드를 탐색하여 개수를 센다. 리프 노드는 자식 노드가 없는 노드다.

### 3) 결과 출력
- 삭제 연산 후 트리에 남아있는 리프 노드의 총 개수를 출력한다.

## 풀이 후 느낀점
문제를 접근하면서 문제에서 트리가 반드시 이진 트리라고 명시되어 있지 않음에도 불구하고, 예제 입력을 보고 자연스럽게 이진 트리를 가정하고 접근했다. 

백준 질문게시판에도 비슷한 상황이 많았고, 다른 블로그에도 나와 똑같은 실수를 한 사람들이 보였다.

트리 구조에 대해서 명확히 이해하지 않고 문제에 접근해버렸고, 그래서 문제의 조건을 제대로 이해하지 못했다. 결국 예상치 못한 반례 정신을 잃을 뻔했다. 주의깊게 보고 생각하는 습관을 들이자..