# **오늘의 알고리즘**
### 2024-03-29 (금)
---

문제이름|알고리즘|난이도|링크|
|:---:|:---:|:---:|:---:|
|[양](https://www.acmicpc.net/problem/3184)|<span style="color:green">**DFS/BFS**</span>|실버1|[풀이](https://github.com/hotchapa/Algorithm/blob/a3a3a3e290c791ed0f24908b1c530a490929586e/JS/Baekjoon/3184.js)|

## 문제 풀이 과정

농장에 있는 양과 늑대를 구분하여, 각각의 영역에서 생존하는 양의 수를 계산하는 문제이다. DFS를 활용하여, 각 영역별로 양과 늑대의 수를 파악한 후, 최종 생존하는 양의 수를 구하면 된다.

### 1) 입력 처리 및 초기화
- 주어진 입력을 받아서, 농장의 지도를 처리한다.
- 각 칸별로 방문 여부를 확인할 수 있는 방문 배열을 초기화한다.

### 2) DFS를 이용한 영역 탐색
- 모든 칸을 순회하면서, 아직 방문하지 않은 칸이고, 벽(`#`)이 아닌 경우 DFS를 시작한다.
- DFS를 통해 해당 칸으로부터 이동 가능한 모든 칸을 방문하며, 이동할 때마다 해당 칸에 있는 양(`o`)과 늑대(`v`)의 수를 계산한다.

### 3) 영역별 생존자 계산
- 각 영역별로 양과 늑대의 수를 비교하여, 양의 수가 늑대의 수보다 많은 경우만 양의 수를 총합에 반영한다. 만약 늑대의 수가 더 많거나 같다면, 해당 영역의 양은 모두 늑대에게 잡아먹힌다고 가정하고 양의 수를 추가하지 않는다.

### 4) 결과 출력
- 모든 영역을 탐색한 후, 최종적으로 생존한 양의 총 수를 출력한다.

## 풀이 후 느낀점
영역별로 양과 늑대의 수를 정확하게 계산하고, 최종적으로 양이 생존할 수 있는 조건을 잘 적용하는 것이 중요했다.

그래서 객체에 값을 넣어 반환하는 방식을 적용했다.

실제로 개발을 할 땐 객체를 자주 다뤘으면서 왜 알고리즘 풀이에는 활용할 생각을 못 했는지 후회스럽다.